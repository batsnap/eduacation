Лекция 5

Возможность управления вводом/выводом обеспечивают форматирующие функции, челны, флаги и манипуляторы.


Cout.fill(‘symbol’);-устнавливает символ заполнитель
Cout.width(‘ ширина поля’);
Cout.precision('количество знаков');

Флаги.
Подключение флага
Cout.setf(ios::/*имя флага*/);

Снятие флага
Cout.unsetf(ios::/*имя флага*/);

cout.setf(ios::/*флаг1*/|ios::/*флаг2*/|ios::/*флаг3*/);
флаги:
1)  boolalpha-вывод логических велечин в текстовом виде
2)  oct-ввод/вывод в восьмеричной системе
    пример:
        cout.unsetf(ios::dec);
        cout.setf(ios::oct);
3)  dec-ввод/вывод в десятичной системе
4)  hex-ввод/вывод в шеснадцатеричной системе
5)  showebase-выводить индикатор основания системы счисления
6)  uppercase-вывод букв верхного регистра в шеснадцатеричной системе
7)  showpos-вывод знака плюс для положительных чисел
8)  scientific-вывод чисел с плавющей  точкой в экспоненнциальной форме
9)  fixed-вывод чисел с плавющей точкой в фиксированной форме
10) right-выравнивание по правой границе(по умолчанию)(необходимо установить ширину поля)
11) left-выравнивание по левой границе(по умолчанию)(необходимо установить ширину поля)

Манипуляторы-объект особого типа управляющий потоками ввода/вывода для форматирования передоваемые потоки информации.
setw,setfill,setprecision-необходимо Подключение библеотеки <iomanip>
1)  endl;-переход на новую строку при выводе
2)  boolalpha-вывод логических велечин в текстовом виде
3)  noboolalpha-вывод логических велечин в числовом виде
4)  oct-восьмеричной
5)  dec-(по умолчанию)десятичной
6)  hex-шеснадцатеричной
7)  showebase-показыает основание системы счисления
8)  noshowebase-не показыает основание системы счисления
9)  uppercase-верхний регистр
10) nouppercase-нижний регистр
11) showpos-
12) noshowpos
13) scientific
14) fixed
15) right
16) left
17) setw(/*ширина поля*/)
18) setprecision(/*количество знаков*/)
19) setfill(/*символ*/)

Пространства имен(namespace)-способ объединения логических связаных объявлений под общим именем.

namespace first;
{
    int a;
    float b;
}

namespace second
{
    int a;
    float b;
}


using namespace std;
int main()
{
    first::a=1;
    second::a=2;
    first::b=3.14;
    second::b=2.71;
    cout<<first::a<<endl;
    cout<<second::a<<endl;
    cout<<first::b<<endl;
    cout<<second::b<<endl;
    return 0;
}

псевдоним Пространства имен
namespace first_namespace
{
    int a,b;
}
namespace fn=first_namespace;

Пространства имен можно вкладывать друг в друга.

Лекция 6.
Условный оператор.

if `(/*условие*/)
{
/*оператор*/;
}
else
{
/*оператор*/;
}
max=(x<y)?y:x;
В качестве выражения условия,кроме логического может быть любое арифметическое выражение целовго типа или символьное.
Ложным значением ставится в соответсвии нулевое значение, все остальные истина.

Допускается вложение условных операторов.
if(a<b)
{
    x++;
    y+=h;
}
else
{
    if (a>b)
    {
        y*=5;
    }
    else
    {
        y=x+h;
        x++;
    }
}
Каждое else относится к ближайшему предшествующем if.

int a,b;
cin>>a>>b;
if (b)
    y=a/b;
else
    cout<<"деление на 0"<<endl;

Оператор выбора.
Осуществляет множетсвенное ветвление.
switch(/*выражение-селектор*/)
{
    case /*константа*/
        /*оператор*/;
        /*оператор*/;
        /*оператор*/;
        break;
    case ...

    default
        /*оператор*/;
        /*оператор*/;
        /*оператор*/;
}

Выражение селектор может быть любого скалярного типа кроме вещественного;
Ветвь default не обязательна.

Функции

задача: написать программу меняющую местами два значения.

#include <iostream>
#include <clocale>
using namespace std;

typedef enum{firstmethod, secondmethod} method;

void change(int &a, int &b, method M);

int main()
{
    setlocale(LC_TYPE,"Russian");
    int a,b,k;
    method m;
    cout<<"enter a:";cin>>a;
    cout<<"enter b:";cin>>b;
    cout<<" choose method: 0-3 peremennie, 1-2 peremennie";cin>>k;
    switch(k)
    {
        case 0:
        m=firstmethod;cout<<"method with additional parametr";
        break;

        case 1:
        m=secondmethod;
        cout<<"method without additional parametr";
        break;
        default:
        m=firstmethod;
        change(a,b,m);
        cout<<"a="<<a<<endl<<"b="<<b<<endl;
    }
    return 0;
void change(int &a, int &b, method M)
{
    if (M==0)
    {
        a=a+b;
        b=a-b;
        a=a-b;
    }
    else
    {
        int c;
        c=a;
        a=b;
        b=c;
    }
}
}

Передача параметров функции и перегрузка функции

 int area(int a, int b)

механизм передачи по значению(передаются только значения соответсвующующих значений параметров)
значение переменных изменены не будут

int (int &a, int &b)
механизм передачи по ссылке(адресу)
функция может менять значения переменных

Перегрузка функции.

Полиморфизм-способность функции обрабатывать данные разных типов.

Перегруженные функции имеют одинаковые именна, но разные спискаи параметров и возвращаемое значение.

double square(double len, double wid);

double square(double left, double wid,double hig);

void get_dim(double &len, double &wid);

void get_dim(double &len, double &wid, double &hig);

математические функции в с++;

<cmath>-библеотека с математическими функциями.

все аргументы функции должны быть вещественными

abs(a)      модуль
sqrt(a)     квадрытный корень
pow(a,b)    степень
ceil(a)     округление до наименьшего целовго не меньше чем а
floor(a)    округление до наибольшего целовго не больше чем а
fmod(a,b)   вычисление остатка деления а на b
exp(a)      вчисление экспоненты e в степени a
sin(a)      a в радианах
cos(a)      a в радианах
asin(a)     арксинус
acos(a)     арккосинус
log(a)      логарифм по основанию е
log 10(a)   

структурированные типы данных в с++

массив-это упорядочанная последовательность данных одного типа занимающих ячейки памяти, для упорядовачивания исполь-
зуется индексация элементов массива, положительное число начиная с нуля.
int mas[5];

Символьная строка объявляется как массив, но при этом дополняется нуль символов.

char str[10]="alpha";
str[0]='a',
str[5]='\0';
char str2[]="beta";

#include <cstring>
strcpy(str1,str2);-     копирование строки
strlen(str1);-          длинна строки
strcmp(str1,str2);- сравение строк совпадает false не совпадает true
strcat(str1,str2);- конекатенация строк
string  относится к stl-standart template library

#include <string>
str.size(); 
str.length();
str.empty(); равны ли строки;
str

Указатель-представляет собой адрес переменной в опертативной памяти
Переменная указательного типа(переменная указатель(указатель))-это переменная размер которой достаточен для хранения
адреса оперативной памяти.

Объявление указателей.
int *a;
int *a,*b,*c;

typedef int* int_ref;
int_ref a,b,c;

Операции над указателями.

При выполнении арифметических Операций происходит именение(смещение) адреса на величину кратную длине соответсвующего
базового типа.

short *a; //адрес 1600

a++;//адрес 1602
для получения значения переменной по ее указателю используется унарная оперция разименование/разадрессация

#intclude <iostream>
using namespace std;

unt main()
{
    int a=5, b=8;
    int *m,*n;
    m=&a;
    n=&b;
    *m+=5//a=10,*m=10
    *n=*m+b;//*n=18, b=18
    cout<<"\na="
}

Операции имеют более высокий приоритет чем любая из арифметических оперций кроме унарного минуса

Динамические переменные
Механизм указателей позваляет программе рабоать с Динамическими переменными
/* переменная указатель*/=new /*базовый тип*/
Этот оператор выделяет память для Динамической переменной базового типа присваивая указателю адрес это переменной
Для освобождение памяти выделенную для Динамической переменной используется оператор delete /*переменную-указатель*/
В с++ отсутсвует встроенные механизм проверки обращения и применения оперции разименования к указателю значение которого
не определенно

Для указателя не ссылающегося на какой-либо адрес можно испльзовать "0" или "NULL"
нулевое значение целесообразно присваивать переменной указателю одноверменно с ее объявлением.
